import { IRI } from "./terms.js";

export type Vocabulary<T extends string> =
    & { readonly [P in T]: IRI }
    & { readonly _IRI: string }
    & Iterable<IRI>;

export namespace Vocabulary {

    export function create<T extends string>(namespaceIRI: string, localNames: T[]): Vocabulary<T> {
        const namespace: { [P in string]: IRI } = {};
        const terms: IRI[] = [];
        for (const localName of localNames) {
            terms.push(namespace[localName] = IRI.create(namespaceIRI + localName));
        }
        return Object.freeze(Object.assign(namespace as { readonly [P in T]: IRI }, { _IRI: namespaceIRI, [Symbol.iterator]: () => terms[Symbol.iterator]() }));
    }
}

export const Rdf = Vocabulary.create("http://www.w3.org/1999/02/22-rdf-syntax-ns#", [
    "Alt",
    "Bag",
    "HTML",
    "List",
    "PlainLiteral",
    "Property",
    "Seq",
    "Statement",
    "XMLLiteral",

    "first",
    "langString",
    "object",
    "predicate",
    "rest",
    "subject",
    "type",
    "value",

    "nil",
]);

export const Rdfs = Vocabulary.create("http://www.w3.org/2000/01/rdf-schema#", [
    "Class",
    "Container",
    "ContainerMembershipProperty",
    "Datatype",
    "Literal",
    "Resource",

    "comment",
    "domain",
    "isDefinedBy",
    "label",
    "member",
    "range",
    "seeAlso",
    "subClassOf",
    "subPropertyOf",
]);

export const Xsd = Vocabulary.create("http://www.w3.org/2001/XMLSchema#", [
    "Name",
    "NCName",
    "NMTOKEN",

    "anyURI",
    "base64Binary",
    "boolean",
    "byte",
    "date",
    "dateTime",
    "dateTimeStamp",
    "dayTimeDuration",
    "decimal",
    "double",
    "duration",
    "float",
    "gDay",
    "gMonth",
    "gMonthDay",
    "gYear",
    "gYearMonth",
    "hexBinary",
    "int",
    "integer",
    "language",
    "long",
    "negativeInteger",
    "nonNegativeInteger",
    "nonPositiveInteger",
    "normalizedString",
    "positiveInteger",
    "short",
    "string",
    "time",
    "token",
    "unsignedByte",
    "unsignedInt",
    "unsignedLong",
    "unsignedShort",
    "yearMonthDuration",
]);

export const Owl = Vocabulary.create("http://www.w3.org/2002/07/owl#", [
    "AllDifferent",
    "AllDisjointClasses",
    "AllDisjointProperties",
    "Annotation",
    "AnnotationProperty",
    "AsymmetricProperty",
    "Axiom",
    "Class",
    "DataRange",
    "DatatypeProperty",
    "DeprecatedClass",
    "DeprecatedProperty",
    "FunctionalProperty",
    "InverseFunctionalProperty",
    "IrreflexiveProperty",
    "NamedIndividual",
    "NegativePropertyAssertion",
    "Nothing",
    "ObjectProperty",
    "Ontology",
    "OntologyProperty",
    "ReflexiveProperty",
    "Restriction",
    "SymmetricProperty",
    "Thing",
    "TransitiveProperty",

    "allValuesFrom",
    "annotatedProperty",
    "annotatedSource",
    "annotatedTarget",
    "assertionProperty",
    "backwardCompatibleWith",
    "bottomDataProperty",
    "bottomObjectProperty",
    "cardinality",
    "complementOf",
    "datatypeComplementOf",
    "deprecated",
    "differentFrom",
    "disjointUnionOf",
    "disjointWith",
    "distinctMembers",
    "equivalentClass",
    "equivalentProperty",
    "hasKey",
    "hasSelf",
    "hasValue",
    "imports",
    "incompatibleWith",
    "intersectionOf",
    "inverseOf",
    "maxCardinality",
    "maxQualifiedCardinality",
    "members",
    "minCardinality",
    "minQualifiedCardinality",
    "onClass",
    "onDataRange",
    "onDatatype",
    "oneOf",
    "onProperties",
    "onProperty",
    "priorVersion",
    "propertyChainAxiom",
    "propertyDisjointWith",
    "qualifiedCardinality",
    "sameAs",
    "someValuesFrom",
    "sourceIndividual",
    "targetIndividual",
    "targetValue",
    "topDataProperty",
    "topObjectProperty",
    "unionOf",
    "versionInfo",
    "versionIRI",
    "withRestrictions",
]);

export const Shacl = Vocabulary.create("http://www.w3.org/ns/shacl#", [
    "AbstractResult",
    "ConstraintComponent",
    "Function",
    "JSConstraint",
    "JSExecutable",
    "JSFunction",
    "JSLibrary",
    "JSRule",
    "JSTarget",
    "JSTargetType",
    "JSValidator",
    "NodeKind",
    "NodeShape",
    "Parameter",
    "Parameterizable",
    "PrefixDeclaration",
    "PropertyGroup",
    "PropertyShape",
    "ResultAnnotation",
    "Rule",
    "Severity",
    "Shape",
    "SPARQLAskExecutable",
    "SPARQLAskValidator",
    "SPARQLConstraint",
    "SPARQLConstructExecutable",
    "SPARQLExecutable",
    "SPARQLFunction",
    "SPARQLRule",
    "SPARQLSelectExecutable",
    "SPARQLSelectValidator",
    "SPARQLTarget",
    "SPARQLTargetType",
    "SPARQLUpdateExecutable",
    "Target",
    "TargetType",
    "TripleRule",
    "ValidationReport",
    "ValidationResult",
    "Validator",

    "alternativePath",
    "and",
    "annotationProperty",
    "annotationValue",
    "annotationVarName",
    "ask",
    "class",
    "closed",
    "condition",
    "conforms",
    "construct",
    "datatype",
    "deactivated",
    "declare",
    "defaultValue",
    "description",
    "detail",
    "disjoint",
    "entailment",
    "equals",
    "expression",
    "filterShape",
    "flags",
    "focusNode",
    "group",
    "hasValue",
    "ignoredProperties",
    "in",
    "intersection",
    "inversePath",
    "js",
    "jsFunctionName",
    "jsLibrary",
    "jsLibraryURL",
    "labelTemplate",
    "languageIn",
    "lessThan",
    "lessThanOrEquals",
    "maxCount",
    "maxExclusive",
    "maxInclusive",
    "maxLength",
    "message",
    "minCount",
    "minExclusive",
    "minInclusive",
    "minLength",
    "name",
    "namespace",
    "node",
    "nodeKind",
    "nodes",
    "nodeValidator",
    "not",
    "object",
    "oneOrMorePath",
    "optional",
    "or",
    "order",
    "parameter",
    "path",
    "pattern",
    "predicate",
    "prefix",
    "prefixes",
    "property",
    "propertyValidator",
    "qualifiedMaxCount",
    "qualifiedMinCount",
    "qualifiedValueShape",
    "qualifiedValueShapesDisjoint",
    "result",
    "resultAnnotation",
    "resultMessage",
    "resultPath",
    "resultSeverity",
    "returnType",
    "rule",
    "select",
    "severity",
    "shapesGraph",
    "shapesGraphWellFormed",
    "sourceConstraint",
    "sourceConstraintComponent",
    "sourceShape",
    "sparql",
    "subject",
    "suggestedShapesGraph",
    "target",
    "targetClass",
    "targetNode",
    "targetObjectsOf",
    "targetSubjectsOf",
    "union",
    "uniqueLang",
    "update",
    "validator",
    "value",
    "xone",
    "zeroOrMorePath",
    "zeroOrOnePath",

    "BlankNode",
    "BlankNodeOrIRI",
    "BlankNodeOrLiteral",
    "IRI",
    "IRIOrLiteral",
    "Literal",
]);
